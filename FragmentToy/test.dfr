@vec2 varying =position
@vec2 uniform =resolution
@vec3 uniform =cameraPos

:m ->fragColor =$gl_FragColor ;

:m when (| block cond |) block { } cond if ;

:m sd-sphere (| p s |) p length s - ;

: sd-box (| p b |)
    p abs b - =d
    d \max 0 min d 0 max length +
;

: smin (| a b k |)
    k a b - abs - 0 max k / =h
    a b min [ h h k 1 4 / ] \* -
;

: sdif (| d1 d2 k |)
    0.5 !d2 d1 + * k / - 0 1 clamp =h
    d2 d1 neg h mix [ k h 1 h - ] \* +
;

: sint (| d1 d2 k |)
    0.5 !d2 d1 - * k / - 0 1 clamp =h
    d2 d1 h mix [ k h 1 h - ] \* +
;

:m union \min ;
:m smooth-union (| list k |) list \{ k smin } list union k 0 != select ;

:m difference \{ (| d1 d2 |) d2 neg d1 max } ;
:m smooth-difference (| list k |) list \{ swap k sdif } list difference k 0 != select ;

:m intersection \max ;
:m smooth-intersection (| list k |) list \{ k sint } list intersection k 0 != select ;

:m scale (| block factor p |) p factor / *block factor * ;

:m twist (| block factor $p |)
    p .y factor * cos =c
    p .y factor * sin =s
    [
        p .x c * p .z s * -
        p .y
        p .x s * p .z c * +
    ] =tmp tmp *block
;

:m twist-func (| block factor $p |)
    p *factor =f
    f cos =c
    f sin =s
    [
        p .x c * p .z s * -
        p .y
        p .x s * p .z c * +
    ] =tmp tmp *block
;

:m repeat (| block c p |) p .5 c * + c mod .5 c * - *block ;

:m onion (| sdf thickness |) sdf abs thickness - ;

(( : map-scene (| p2 |)
    { (| p |)
        [
            [
                [ [ -1 -1 ] [ -1 1 ] [ 1 -1 ] [ 1 1 ] ]
                /{ p [ 1.9 _ .x * 0 1.9 _ .y * ] + [ .1 4 .1 ] sd-box } union
                [
                    p [ 2 4 2 ] sd-box
                    [ { .1 sd-sphere (( [ .1 !!] sd-box )) } .4 p [ 0 .2 0 ] + repeat v .07 onion ] intersection
                ] difference
            ] union
            p [ 0 .2 0 ] - [ 1.8 4 1.8 ] sd-box
        ] difference
    } 15 radians p2 twist
; ))

: map-scene (| p |)
    [
        [
            p 2 sd-sphere .1 onion
            p [ 0 2 0 ] - 1.3 sd-sphere
        ] .1 smooth-difference
        p [ 2500 1 1 ] / .5 sd-sphere
        p [ 0 2.2 0 ] + [ 2 .25 2 ] sd-box
    ] 0 smooth-difference
;

: cast-ray (| ro rd |)
    20 =>tmax
    .01 =t

    { drop
        0.0004 t * =>precis
        rd t * ro + map-scene =res
        t res .5 * + =t
        &break res precis < t tmax > or when
    } 128 times
    
    t 100000 t tmax <= select
;

: calc-normal (| pos |)
    [ 1 -1 ] 0.0005 * =>e
    { .xyy .yyx .yxy .xxx } /{ e *_ !=>ce pos ce + map-scene * } \+ normalize
;

: render (| ro rd |)
    ro rd cast-ray =t
    
    [ rd t * ro + calc-normal t ] [ 0 0 0 0 ] t 100000 != select
;

: create-perspective-matrix (| fov aspect-ratio near-plane far-plane |)
    1 fov .5 * tan / =y-scale
    y-scale aspect-ratio / =>x-scale
    
    [
        [ x-scale 0 0 0 ]
        [ 0 y-scale 0 0 ]
        [ 0 0 far-plane near-plane far-plane - / 0 ]
        [ 0 0 -1 near-plane far-plane * near-plane far-plane - / ]
    ] matrix
;

: create-lookat-matrix (| pos target up |)
    pos target - normalize =z-axis
    up z-axis cross normalize =x-axis
    z-axis x-axis cross =y-axis
    [
        [ x-axis x-axis pos dot ]
        [ y-axis y-axis pos dot ]
        [ z-axis z-axis pos dot ]
        [ 0 0 0 1 ]
    ] matrix
;

cameraPos =>camera-position

    camera-position [ 0.0001 !!] [ 0 1 0 ] create-lookat-matrix
    60 radians resolution .yx \/ 1 5000 create-perspective-matrix
* =camera-matrix

position 2 / 1 - =real-position

camera-matrix [ [ real-position 2 ] normalize 0 ] * .xyz =ray-direction
camera-position ray-direction render =normal-depth
[ normal-depth .xyz 1 + 2 / [ 0 0 0 ] normal-depth .w 0 != select 1 ] ->fragColor

(( [
    [ 6 ] { 0 print }
    [ 7 ] { 0 print }
    { 55 print }
] 5 match ))
