@vec2 varying =position
@vec2 uniform =resolution

:m ->fragColor =$gl_FragColor ;

:m when (| block cond |) block { } cond if ;

:m sd-sphere (| p s |) p length s - ;

: sd-box (| p b |)
    p abs b - =d
    d \max 0 min d 0 max length +
;

:m union min ;

: map-scene (| p |)
    [
        p [ -2 1 1 ] + 2 sd-sphere
        p [ 1 1 1 ] sd-box
        p [ 3 -5 0 ] + [ 1 1 1 ] sd-box
    ] \union
;

: cast-ray (| ro rd |)
    20 =>tmax
    1 =t

    { drop
        0.0004 t * =>precis
        rd t * ro + map-scene =res
        t res .5 * + =t
        &break res precis < t tmax > or when
    } 128 times
    
    t 100000 t tmax <= select !print
;

: calc-normal (| pos |)
    [ 1 -1 ] 0.0005 * =>e
    { .xyy .yyx .yxy .xxx } /{ e *_ !=>ce pos ce + map-scene * } \+ normalize
;

: render (| ro rd |)
    ro rd cast-ray =t
    
    [ rd t * ro + calc-normal t ] [ 0 0 0 0 ] t 100000 != select
;

: create-perspective-matrix (| fov aspect-ratio near-plane far-plane |)
    1 fov .5 * tan / =y-scale
    y-scale aspect-ratio / =>x-scale
    
    (( [
        [ x-scale 0 0 0 ]
        [ 0 y-scale 0 0 ]
        [ 0 0 far-plane near-plane far-plane - / -1 ]
        [ 0 0 0 near-plane far-plane * near-plane far-plane - / ]
    ] ))
    [
        [ x-scale 0 0 0 ]
        [ 0 y-scale 0 0 ]
        [ 0 0 far-plane near-plane far-plane - / 0 ]
        [ 0 0 -1 near-plane far-plane * near-plane far-plane - / ]
    ] matrix
;

[ 2 2 5 ] =camera-position

45 radians resolution .yx \/ 1 5000 create-perspective-matrix =camera-matrix

position 2 / 1 - =real-position

camera-matrix [ [ real-position 2 ] normalize 0 ] * .xyz =ray-direction
camera-position ray-direction render =normal-depth
[ normal-depth .xyz 1 + 2 / [ 0 0 0 ] normal-depth .w 0 != select 1 ] ->fragColor


